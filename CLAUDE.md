# Learn Rust with Claude - 项目指导文件

## 项目概述

这是一个为有经验的 Java 开发者设计的 Rust 学习教程。通过一系列实用的小项目，渐进式地掌握 Rust 语言。

**目标读者**：有 Java/后端开发经验，希望学习 Rust 的开发者

**核心理念**：项目驱动、成就感导向、知其所以然

---

## 教学理念

### 1. 临近发展区原则 (Zone of Proximal Development)

每章只引入 1-3 个核心新概念，确保：
- 新概念建立在已掌握知识之上
- 学习者始终处于"稍有挑战但可达成"的状态
- 避免概念过载导致的挫败感

### 2. 项目驱动学习

- 每章围绕一个实用项目展开
- 概念为项目服务，而非为讲概念而讲
- 项目完成后可实际使用，提供真实成就感

**项目引入三步曲**：
1. **功能概览**：这个工具是什么？解决什么问题？
2. **需求分析**：具体要实现哪些功能？
3. **技术引入**：为了实现这些功能，需要学什么？

示例（task-cli 引入）：
```markdown
## 项目：task-cli - 命令行待办事项管理器

### 功能概览
一个帮助你在终端管理日常待办事项的工具。
类似于 Todoist/Things 的命令行版本。

### 为什么做这个？
- 程序员经常在终端工作，不想切换到 GUI
- 想要一个轻量、快速、可定制的任务管理工具
- 数据本地存储，隐私可控

### 最终效果演示
$ task add "学习 Rust 所有权"
✓ 任务已添加 (ID: 1)

$ task list
ID  状态    任务
1   待办    学习 Rust 所有权
2   完成    安装 Rust 环境

$ task done 1
✓ 任务已完成

### 本章实现范围
本章我们先实现基础版本：
- 添加任务
- 列出任务
- 标记完成

后续章节会逐步添加：文件存储、JSON 格式、子命令等
```

### 3. 按需引入

**不做的事**：
- 不在开头罗列所有格式化方法
- 不提前讲解暂时用不到的语法糖
- 不为了"完整性"而堆砌知识点

**要做的事**：
- 用到什么讲什么
- 遇到问题时自然引出解决方案
- 保持学习的节奏感和流畅度

### 4. 知其所以然

对于 Rust 的设计决策，要解释：
- **意图**：Rust 为什么这样设计？解决什么问题？
- **对比**：与 Java 的异同，各自的取舍
- **哲学**：背后的编程哲学和设计原则

### 5. 命名与 API 解释原则

**通过理解记忆，而非通过记忆使用**：

对于常见的包名、函数名、路径，要解释：
- **命名由来**：如 `Vec`（Vector）、`iter`（Iterator）、`Ok/Err`
- **路径含义**：如 `std::io::BufReader` 中每个部分的意思
- **API 设计意图**：为什么 `push` 而不是 `add`？为什么 `unwrap` 叫这个名字？

示例：
```rust
// BufReader: Buffered Reader，带缓冲的读取器
// 为什么需要缓冲？因为系统调用开销大，批量读取更高效
use std::io::BufReader;

// collect: 收集迭代器的元素到集合中
// 为什么叫 collect？因为它"收集"散落的元素
let v: Vec<_> = iter.collect();

// unwrap: 解包 Option/Result
// 为什么叫 unwrap？想象拆开包装纸，取出里面的值
let value = some_option.unwrap();
```

**常见前缀/后缀含义**：
- `try_*`：可能失败，返回 Result
- `*_or`：提供默认值版本
- `*_mut`：可变版本
- `as_*`：低成本转换（借用）
- `to_*`：可能有开销的转换（生成新值）
- `into_*`：消耗所有权的转换

### 6. 顶级组件的深度介绍

对于 Rust 生态中的顶级组件/框架，必须包含：

1. **背景介绍**：
   - 是谁开发的？为什么开发？
   - 在生态中的地位
   - 发展历史和稳定性

2. **设计理念**：
   - 核心设计思想是什么？
   - 解决了什么问题？
   - 与其他语言/方案的对比

3. **独特价值**：
   - 为什么 Rust 能做到而其他语言不能？
   - 这反映了 Rust 的什么特性？

**重点组件清单**：

| 组件 | 独特价值 | 设计理念 |
|-----|---------|---------|
| **Serde** | 其他语言没有类似的序列化框架分离设计 | 零成本抽象 + trait 组合 |
| **Tokio** | 生产级异步运行时 | 工作窃取调度器 |
| **Axum** | 类型安全的 Web 框架 | Extractor 模式 |
| **Clap** | derive 宏驱动的 CLI | 声明式 > 命令式 |
| **SQLx** | 编译时 SQL 检查 | 类型安全 + 原生异步 |

示例（Serde 介绍）：
```markdown
## Serde：Rust 最独特的序列化方案

### 背景
Serde 由 David Tolnay 开发，是 Rust 生态下载量最高的 crate 之一。
名字来源于 SERialize + DEserialize。

### 为什么其他语言没有类似方案？

Java 的 Jackson、Python 的 json 模块都是「格式绑定」的：
- Jackson 就是 JSON 库
- 要支持 YAML 得用另一个库，API 不同

Serde 的革命性在于：
- serde 本身不绑定任何格式
- 通过 trait 定义序列化协议
- 具体格式由 serde_json/toml/yaml 等实现

这能实现的原因是 Rust 的：
- trait 系统（定义通用协议）
- 过程宏（自动派生实现）
- 零成本抽象（编译期生成代码）
```

### 7. 最佳实践原则

**每个主题都要讲最佳实践**，不只是讲"怎么用"，还要讲"怎么用好"。

每章应包含的最佳实践内容：
- **何时使用**：这个特性的适用场景
- **何时避免**：常见的误用场景
- **常见陷阱**：新手容易犯的错误
- **惯用写法**：Rust 社区的惯用模式（idiomatic Rust）

示例主题及其最佳实践：

| 主题 | 最佳实践要点 |
|-----|-------------|
| 所有权 | 何时 clone vs 借用 |
| 错误处理 | 何时 unwrap vs ? vs match |
| 迭代器 | iter/into_iter/iter_mut 选择 |
| 模块 | pub 的最小化原则 |
| Workspace | 何时拆分 vs 合并 |
| 依赖管理 | 版本选择策略 |

**格式要求**：
每章末尾添加「最佳实践」小节，用清晰的对比表格或要点列表呈现。

---

## 内容规范

### 目录结构

```
learn_rust_with_claude/
├── CLAUDE.md              # 本文件 - 项目指导
├── OUTLINE.md             # 课程大纲
├── DESIGN.md              # 设计决策记录
├── chapters/
│   ├── 01-hello-cargo/
│   │   ├── README.md      # 章节文档
│   │   └── project/       # Cargo 项目
│   │       ├── Cargo.toml
│   │       └── src/
│   ├── 02-xxx/
│   └── ...
└── assets/                # 图片等资源
```

### 章节文档结构

每章 README.md 应包含：

```markdown
# 章节标题

## 本章目标
- 明确列出学完本章能做什么

## 前置知识
- 需要哪些前面章节的知识

## 核心概念
### 概念名称
- 是什么
- 为什么这样设计（意图）
- 怎么用
- 与 Java 对比（如适用）

## 项目：[项目名]
### 项目简介
### 逐步实现
### 完整代码

## 要点回顾
## 练习（可选）
## 扩展阅读（可选）
```

### 代码规范

- 使用 Rust 2021 edition
- 遵循 `rustfmt` 默认格式
- 代码注释精简，关键处说明意图
- 避免过度工程，保持代码简洁

### 写作风格

- 使用第二人称"你"与读者对话
- 语言简洁直接，避免冗余
- 技术术语首次出现时解释
- 适当使用类比，但不过度

---

## AI 辅助教学原则

### 当扩展章节内容时

1. **先读 OUTLINE.md**：了解整体结构和本章定位
2. **检查前后章节**：确保概念衔接正确
3. **遵循按需引入**：只讲本章项目需要的内容
4. **保持实用导向**：每个知识点都要在项目中用到

### 当回答学习者问题时

1. **定位当前进度**：了解学习者学到哪一章
2. **渐进式回答**：如果涉及后续章节内容，先给简化版答案
3. **鼓励动手**：引导学习者通过代码验证理解

### 当添加新章节时

1. **评估前置依赖**：新章节需要哪些已有知识
2. **确定核心概念**：每章不超过 3 个核心新概念
3. **设计实用项目**：项目要有真实使用场景
4. **更新 OUTLINE.md**：保持大纲同步

---

## 重要设计决策

### 关于 serde

serde 是 Rust 生态中 Unix 哲学的典范：
- **单一职责**：serde 只负责序列化框架，不绑定具体格式
- **组合性**：serde + serde_json / serde_yaml / toml 自由组合
- **关注点分离**：数据结构定义与序列化格式解耦

在教程中，serde 应该：
- 放在 trait 和泛型之后
- 作为"Rust 生态设计哲学"的案例
- 展示 derive 的使用者视角（不深入宏实现）

### 关于模块化

较早引入模块概念（第 3-4 章），因为：
- 真实项目不可能都写在 main.rs 里
- 模块是 Rust 代码组织的基础
- 越早建立正确习惯越好

### 关于错误处理

Result/Option 应该：
- 早期简单使用（unwrap）
- 中期正式讲解（?运算符、错误传播）
- 结合实际场景（文件操作、网络请求）

### 关于与 Java 的对比

对于相似概念（泛型、trait/接口）：
- 不因"Java 也有"而跳过
- 完整讲解 Rust 的实现方式
- 重点说明设计意图的差异
- 帮助建立正确的 Rust 心智模型

---

## 版本信息

- Rust Edition: 2021
- 最低 Rust 版本: 1.75+（推荐 1.80+）
- 创建日期: 2025-01
- 主要依赖版本: 跟随最新稳定版
