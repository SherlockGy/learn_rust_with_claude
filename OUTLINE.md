# Learn Rust with Claude - 课程大纲

## 大纲说明

本大纲按照临近发展区原则设计，每章引入 1-3 个核心概念，并通过实用项目巩固。

**图例**：
- 🎯 核心概念
- 🔧 项目
- 📦 涉及的 crate
- 🔗 与前章的关联

---

## 第一部分：基础入门

### 第 1 章：你好，Rust

🎯 **核心概念**：Cargo 项目结构、基本输出、编译运行流程

🔧 **项目**：echo-rs - 一个简单的 echo 命令实现
- 学习 Cargo 创建/构建/运行项目
- 理解 main 函数和基本 println!
- 处理命令行参数（简单版：std::env::args）

**为什么这个项目**：
- 5 分钟内完成，立即获得成就感
- echo 是最简单的 Unix 工具之一
- 自然引出命令行参数处理

**与 Java 对比要点**：
- Cargo vs Maven/Gradle：更简洁的项目管理
- 无 JVM，直接编译为本地二进制

---

### 第 2 章：变量与类型

🎯 **核心概念**：不可变性默认、类型推断、基本类型

🔧 **项目**：word-count（第一版）- 统计文本的单词数
- 读取用户输入或简单字符串
- 使用 split/count 等方法
- 理解 &str 与 String 的初步区别

🔗 **关联**：扩展第 1 章的命令行处理

**与 Java 对比要点**：
- 默认不可变 vs Java 需要 final
- 类型推断的程度差异
- 字符串处理的根本不同

**附带提及**：字符串基础（&str vs String 初步，详细在所有权章节）

---

### 第 3 章：函数与模块

🎯 **核心概念**：函数定义、模块系统、pub 可见性

🔧 **项目**：重构 word-count 为多文件结构
- 将功能拆分到独立模块
- 理解 mod / use / pub
- 建立正确的项目组织习惯

**为什么较早引入模块**：
- 真实项目不可能都写在 main.rs
- 越早建立正确习惯越好
- 为后续章节打下组织基础

**附带提及**：文件组织约定

---

### 第 4 章：所有权（上）

🎯 **核心概念**：所有权规则、移动语义、借用基础

🔧 **项目**：uniq-rs - 去除连续重复行（类似 uniq 命令）
- 需要处理字符串的所有权
- 自然遇到"值被移动"的问题
- 通过借用解决问题

**设计意图解释**：
- 为什么 Rust 需要所有权？（内存安全无 GC）
- 移动 vs 复制的选择逻辑
- 与 Java 引用的本质区别

**最佳实践**：
- 何时 clone vs 借用
- 避免不必要的所有权转移
- 函数签名设计：取所有权 vs 取引用

---

### 第 5 章：所有权（下）

🎯 **核心概念**：可变借用、借用规则、生命周期初步

🔧 **项目**：升级 uniq-rs 支持 -c（计数）选项
- 需要可变借用来计数
- 遇到多重借用问题并解决
- 初步感受生命周期（不深入）

**借用规则的设计意图**：
- 为什么不能同时有可变和不可变借用？
- 这如何防止数据竞争？

**最佳实践**：
- 借用范围最小化
- NLL（Non-Lexical Lifetimes）的利用

**生命周期边界说明**：
- 本章只讲：生命周期是什么、为什么需要
- 只接触省略规则（大多数情况编译器自动推断）
- 不讲：显式生命周期标注语法（`'a`）
- 后续如遇到再按需补充

---

## 第二部分：类型系统

### 第 6 章：结构体

🎯 **核心概念**：struct 定义、方法实现、关联函数

🔧 **项目**：task-cli - 命令行待办事项（基础版）
- 定义 Task 结构体（id, title, done）
- 实现 new / display 等方法
- 数据存储在内存中
- 简单的 add/list/done 命令

**本章 task-cli 范围**：
- Task { id: u32, title: String, done: bool }
- 内存中的 Vec<Task>
- 通过简单的命令行参数操作

**与 Java 对比**：
- impl 块 vs 类内方法
- 没有构造函数，new 只是约定
- 默认没有继承（组合优于继承）

**最佳实践**：
- 结构体字段可见性设计
- 构建器模式（Builder Pattern）简介

---

### 第 7 章：枚举与模式匹配

🎯 **核心概念**：enum（含数据）、match、Option

🔧 **项目**：升级 task-cli 支持任务状态
- 定义 Status 枚举（Pending/InProgress/Done）
- 使用 match 处理不同状态
- 引入 Option 处理可选字段（如截止日期）

**本章 task-cli 新增**：
- Status 枚举
- Option<String> 用于可选的 due_date
- match 分支处理状态

**Rust 枚举的威力**：
- 代数数据类型（ADT）
- 比 Java enum 强大在哪里
- 穷尽性检查的价值

**Option 深度讲解**：
- Option 的设计意图（消除 null）
- Some/None 的使用模式
- map/and_then/unwrap_or 组合子
- 为第 8 章 Result 打基础

**最佳实践**：
- if let vs match 的选择
- Option 组合子链式调用

---

### 第 8 章：错误处理

🎯 **核心概念**：Result、? 运算符、错误传播

🔧 **项目**：升级 task-cli 支持文件持久化（纯文本）
- 文件操作会失败，需要处理错误
- 使用 ? 简化错误传播
- 区分何时 panic 何时 Result

**本章 task-cli 新增**：
- 保存任务到文本文件
- 启动时加载任务
- 处理文件不存在、读写失败等错误

**设计意图**：
- 为什么不用异常？
- 显式错误处理的好处
- Result 与 Option 的关系

**最佳实践**：
- 何时用 `unwrap()` / `expect()` / `?` / `match`
- 错误类型设计：何时自定义错误类型
- `anyhow` vs `thiserror` 的选择（简介）

---

### 第 9 章：Trait 基础

🎯 **核心概念**：trait 定义、实现、常用标准 trait

🔧 **项目**：为 task-cli 实现漂亮的输出
- 实现 Display trait 自定义格式化
- 实现 Debug 用于调试
- 理解 derive 的作用

**Trait vs Java 接口**：
- 相似之处：定义行为契约
- 不同之处：可为外部类型实现、关联类型等
- Rust trait 的设计哲学
- **继承 vs 组合**：Rust 没有继承，用 trait 组合实现多态

**最佳实践**：
- 何时实现标准 trait（Debug, Clone, Default, PartialEq）
- derive vs 手动实现的选择
- trait bound 的简洁写法

---

### 第 10 章：泛型

🎯 **核心概念**：泛型函数、泛型结构体、trait bound

🔧 **项目**：mini-vec - 实现一个简化版动态数组
- 泛型结构体 MiniVec<T>
- 实现 push / pop / get 方法
- 理解 trait bound 的作用

**与 Java 泛型对比**：
- 单态化 vs 类型擦除
- 性能影响
- 表达能力的差异

**最佳实践**：
- 泛型 vs impl Trait vs dyn Trait 的选择
- trait bound 组合技巧
- 避免过度泛型化

---

### 第 11 章：闭包

🎯 **核心概念**：闭包语法、捕获模式、Fn/FnMut/FnOnce

🔧 **项目**：为 task-cli 添加过滤功能
- 使用闭包实现灵活的任务过滤
- 理解闭包如何捕获环境变量
- 为下一章迭代器做准备

**本章 task-cli 新增**：
- `task list --filter` 支持自定义过滤条件
- 内部使用闭包实现

**闭包的设计意图**：
- 为什么需要三种 trait（Fn/FnMut/FnOnce）？
- 闭包与所有权的关系
- move 关键字的作用

**与 Java Lambda 对比**：
- 语法差异
- 捕获语义差异（Java 只能捕获 effectively final）
- Rust 闭包更灵活但需要理解所有权

**最佳实践**：
- 闭包参数类型推断
- 何时需要 move
- 闭包作为参数和返回值

---

## 第三部分：实用工具

### 第 12 章：集合与迭代器

🎯 **核心概念**：Vec、HashMap、迭代器适配器

🔧 **项目**：freq - 词频统计工具
- 读取文件统计词频
- 使用 HashMap 存储
- 迭代器链式处理

**Vec 深入**：
- 容量管理
- 常用方法

**HashMap 按需引入**：
- 随 freq 项目需要引入
- 基本操作：insert/get/entry API

**迭代器的设计哲学**：
- 惰性求值
- 零成本抽象
- 函数式风格

**最佳实践**：
- 何时用 `iter()` vs `into_iter()` vs `iter_mut()`
- 链式调用的可读性
- 避免不必要的 `collect()`

---

### 第 13 章：Cargo Workspace 与项目组织

🎯 **核心概念**：workspace、成员管理、依赖共享

🔧 **项目**：将之前的项目整合为 workspace
- 创建根 Cargo.toml 配置 workspace
- 添加已有项目为 members
- 共享依赖版本

**为什么现在引入**：
- 已有多个项目，自然需要统一管理
- 为后续 text-toolkit 打基础
- 养成正确的项目组织习惯

**内容涵盖**：
- workspace 基本结构和配置
- `[workspace.dependencies]` 共享依赖
- 成员间依赖（path 依赖）
- workspace 命令（`cargo build -p xxx`）

**最佳实践**：
- 何时用 workspace vs 单独项目
- 目录结构约定（packages/ vs 平铺）
- 版本管理策略
- CI/CD 中的 workspace 使用

---

### 第 14 章：Serde 与序列化

🎯 **核心概念**：serde 框架、derive 使用、JSON/TOML 序列化

📦 **依赖**：serde, serde_json, toml

🔧 **项目**：升级 task-cli 支持 JSON 存储 + 配置文件
- Task 添加 Serialize/Deserialize
- 任务数据存为 JSON
- 配置文件使用 TOML

**Serde 的 Unix 哲学**：
- 单一职责：serde 只是框架
- 组合性：与具体格式 crate 组合
- 关注点分离：数据定义与格式解耦
- 这就是 Rust 生态的设计典范

**Serde 深度介绍**：
- 背景：David Tolnay 开发，Rust 生态下载量最高的 crate
- 设计理念：框架与格式分离
- 为什么其他语言没有类似方案？（trait + 过程宏 + 零成本抽象）

**最佳实践**：
- `#[serde(rename_all)]` 命名风格转换
- `#[serde(default)]` 默认值处理
- `#[serde(skip)]` 跳过字段
- 版本兼容：新增字段时使用 Option

---

### 第 15 章：命令行应用进阶

🎯 **核心概念**：clap 参数解析、子命令、配置管理

📦 **依赖**：clap（derive 模式）

🔧 **项目**：完善 task-cli 为生产级 CLI
- 使用 clap 重构参数解析
- 添加子命令（add/list/done/edit/remove/stats）
- 添加配置和数据目录管理

**为什么用 clap**：
- 生态标准
- derive 模式的人体工程学
- 自动生成帮助信息

**Clap 深度介绍**：
- 声明式 > 命令式的设计哲学
- derive 宏的威力

**最佳实践**：
- 子命令组织
- 参数验证
- 环境变量集成
- 帮助信息优化

---

### 第 16 章：文件与 I/O

🎯 **核心概念**：std::fs、BufReader/BufWriter、路径处理

🔧 **项目**：find-rs - 简化版文件查找工具
- 递归遍历目录
- 支持按名称/扩展名过滤
- 处理路径的跨平台问题

**命名解释**：
- `BufReader`：Buffered Reader，带缓冲的读取器
- `BufWriter`：Buffered Writer，带缓冲的写入器
- 为什么需要缓冲？减少系统调用次数，提高效率

**最佳实践**：
- Path vs PathBuf 的选择
- 跨平台路径处理
- 大文件处理策略
- 错误处理模式

---

### 第 17 章：实用文本处理

🎯 **核心概念**：批量文件操作、流式处理、文本统计

🔧 **项目**：text-toolkit - 批量文本处理工具集
包含多个子工具（体现 Unix 哲学的组合）：

**项目组织**：使用 workspace 管理多个子工具
```
text-toolkit/
├── Cargo.toml          # workspace 根配置
├── common/             # 共享库（文件操作、输出格式化）
├── batch-rename/       # 子工具 1
├── line-stats/         # 子工具 2
└── ...
```

**核心工具（必做）**：

1. **batch-rename**：批量重命名文件
   - 读取目录文件列表
   - 支持正则表达式替换
   - 预览模式（dry-run）

2. **line-stats**：行统计工具
   - 统计多文件的行数、字符数、单词数
   - 支持通配符匹配
   - 汇总输出

**扩展练习（选做）**：

3. **text-replace**：批量文本替换
4. **csv-query**：简易 CSV 处理

**学习要点**：
- 大文件的流式处理（不全部加载到内存）
- 文件写入的原子性（先写临时文件再重命名）
- 命令行工具的人体工程学设计
- workspace 实战：共享代码、统一依赖

---

## 第四部分：并发与网络

### 第 18 章：并发基础 - 线程与共享状态

🎯 **核心概念**：线程、Arc、Mutex/RwLock

🔧 **项目**：parallel-hash - 并行计算多文件哈希
- 多线程处理文件列表
- 使用 Arc 共享数据
- 理解 Send/Sync trait

**无畏并发的含义**：
- 编译器检查数据竞争
- 所有权如何帮助并发安全

**最佳实践**：
- `Arc` vs `Rc` 的选择
- `Mutex` vs `RwLock` 的选择
- 避免死锁的策略

---

### 第 19 章：并发进阶 - 通道与消息传递

🎯 **核心概念**：mpsc channel、多生产者模式、Select

🔧 **项目**：log-watcher - 日志文件监控聚合器
- 监控多个日志文件
- 通过 channel 汇总到主线程
- 实时输出匹配的日志行

**消息传递 vs 共享内存**：
- 各自的适用场景
- "不要通过共享内存来通信，而要通过通信来共享内存"

**最佳实践**：
- 何时用消息传递 vs 共享状态
- channel 容量选择
- 优雅关闭模式

---

### 第 20 章：网络编程基础

🎯 **核心概念**：std::net、TCP 基础、简单协议

🔧 **项目**：kv-server - 简单的 TCP 键值存储服务（单线程版）
- 实现简单的文本协议（GET/SET/DEL）
- 单线程版本先跑起来
- 理解网络编程的基本模式

**最佳实践**：
- 协议设计原则
- 连接管理
- 错误处理

---

### 第 21 章：多线程网络服务

🎯 **核心概念**：线程池模式、并发安全的共享状态

🔧 **项目**：升级 kv-server 支持并发
- 用线程池处理多客户端
- 用 Arc<RwLock> 管理状态
- 理解并发服务的挑战

**最佳实践**：
- 线程池大小选择
- 连接超时处理
- 优雅关闭

---

### 第 22 章：异步初步

🎯 **核心概念**：async/await 语法、Future 基础、tokio 入门

📦 **依赖**：tokio（入门）

🔧 **项目**：async-kv - 用 tokio 重写 kv-server
- 对比同步和异步版本
- 理解异步的适用场景
- 不深入异步运行时细节

**Tokio 简介**：
- 生产级异步运行时
- 工作窃取调度器

**简单介绍范围**：
- 基本使用方法
- 何时考虑异步
- 不涉及 Pin/手写 Future 等高级话题

---

### 第 23 章：Web 框架实战（Axum）

🎯 **核心概念**：Axum 框架、路由、状态管理、数据库集成

📦 **依赖**：axum, tokio, sqlx, tower

🔧 **项目**：link-short - 短链接服务

一个完整的 REST API 后端服务：
- 创建短链接（POST /links）
- 访问短链接跳转（GET /:code）
- 查看链接统计（GET /links/:code/stats）
- 删除链接（DELETE /links/:code）

**功能特性**：
- SQLite 存储（sqlx，易于上手）
- 点击次数统计
- 链接过期时间
- 简单的 API 认证

**为什么选择 Axum**：
- tokio 团队官方出品
- 设计符合 Rust 哲学（类型安全、组合性）
- Tower 中间件生态
- 文档友好，社区活跃

**核心内容**：
- 项目结构组织（routes/handlers/models/db）
- 路由与 Handler
- 状态管理（State）
- 错误处理统一化
- 数据库集成（SQLx）

**进阶阅读**（可选）：
- 中间件与 Tower
- 日志与追踪（tracing）
- 优雅关闭

**与 Java Spring 对比**：
- 注解 vs 类型系统
- IoC 容器 vs Extractor
- 中间件/拦截器的差异

---

## 第五部分：综合应用（可选扩展）

### 第 24 章：HTTP 客户端

📦 **依赖**：reqwest, tokio

🔧 **项目**：api-cli - 命令行 HTTP/API 客户端
- 支持 GET/POST/PUT/DELETE
- 自定义 Headers
- JSON 格式化输出
- 可与 link-short 服务交互测试

---

### 第 25 章：综合项目

🔧 **项目**：选择以下之一深入
- mini-redis：更完整的 Redis 实现
- file-sync：文件同步工具
- log-analyzer：日志分析管道

---

## 附录

### A. Cargo 进阶
- features 条件编译
- build.rs 构建脚本
- 发布到 crates.io
- cargo-edit、cargo-watch 等工具

### B. 测试
- 单元测试
- 集成测试
- 文档测试

### C. 常用 crate 速查
- 按用途分类的 crate 推荐

### D. 智能指针简介

> 💡 **阅读时机**：建议在学完第 18 章（并发基础）后阅读本附录

- Box<T>：堆分配
- Rc<T>/Arc<T>：引用计数
- RefCell<T>：内部可变性
- 何时使用各种智能指针
- Rc vs Arc 的选择（单线程 vs 多线程）

---

## 概念引入顺序总结

| 章节 | 引入概念 | 为什么在这里 |
|------|---------|-------------|
| 1 | Cargo, 基本语法 | 最小可运行程序 |
| 2 | 变量, 类型 | 做任何事都需要 |
| 3 | 模块 | 早建立正确习惯 |
| 4-5 | 所有权, 借用 | Rust 核心, 不能绕过 |
| 6 | 结构体 | 组织数据 |
| 7 | 枚举, Option | 处理变体和状态 |
| 8 | 错误处理 | 实际项目必需 |
| 9 | Trait | 抽象行为 |
| 10 | 泛型 | 代码复用 |
| 11 | 闭包 | 为迭代器做准备 |
| 12 | 集合, 迭代器 | 实用数据处理 |
| 13 | Workspace | 项目够多，需要统一管理 |
| 14 | Serde | 生态哲学典范 |
| 15 | CLI 进阶 | 生产级命令行 |
| 16 | 文件 I/O | 系统操作基础 |
| 17 | 批量文本处理 | 实用技能，I/O 综合应用 |
| 18 | 线程, Arc, Mutex | 无畏并发基础 |
| 19 | 通道, 消息传递 | 并发通信模式 |
| 20-21 | 网络编程 | TCP 服务 |
| 22 | async 初步 | 异步概念 |
| 23 | Axum Web 框架 | 后端开发实战 |
| 24-25 | HTTP 客户端, 综合 | 可选扩展 |

**最佳实践**贯穿每章，见各章节详细内容。
